
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/CloudRoamer/aimo-libs/config/config.go (85.4%)</option>
				
				<option value="file1">github.com/CloudRoamer/aimo-libs/config/errors.go (0.0%)</option>
				
				<option value="file2">github.com/CloudRoamer/aimo-libs/config/manager.go (91.5%)</option>
				
				<option value="file3">github.com/CloudRoamer/aimo-libs/config/merge/merger.go (100.0%)</option>
				
				<option value="file4">github.com/CloudRoamer/aimo-libs/config/options.go (0.0%)</option>
				
				<option value="file5">github.com/CloudRoamer/aimo-libs/config/source/consul/consul.go (78.1%)</option>
				
				<option value="file6">github.com/CloudRoamer/aimo-libs/config/source/consul/options.go (36.4%)</option>
				
				<option value="file7">github.com/CloudRoamer/aimo-libs/config/source/consul/watcher.go (3.3%)</option>
				
				<option value="file8">github.com/CloudRoamer/aimo-libs/config/source/env/env.go (91.2%)</option>
				
				<option value="file9">github.com/CloudRoamer/aimo-libs/config/source/file/file.go (71.1%)</option>
				
				<option value="file10">github.com/CloudRoamer/aimo-libs/config/source/file/watcher.go (0.0%)</option>
				
				<option value="file11">github.com/CloudRoamer/aimo-libs/config/source/postgres/options.go (71.4%)</option>
				
				<option value="file12">github.com/CloudRoamer/aimo-libs/config/source/postgres/postgres.go (28.6%)</option>
				
				<option value="file13">github.com/CloudRoamer/aimo-libs/config/value.go (74.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "context"
        "time"
)

// Source 定义配置源接口
// 每个配置源（环境变量、Consul、文件等）都需要实现此接口
type Source interface {
        // Name 返回配置源的唯一标识名称
        // 用于日志记录和错误追踪
        Name() string

        // Priority 返回配置源的优先级
        // 数值越大优先级越高，合并时高优先级覆盖低优先级
        // 推荐值: Env=100, Consul=80, File=60, Default=0
        Priority() int

        // Load 加载配置数据
        // 返回扁平化的 key-value 映射，key 使用点分隔符表示层级
        // 例如: {"database.host": "localhost", "database.port": "5432"}
        Load(ctx context.Context) (map[string]Value, error)

        // Watch 返回配置变更监听器（可选）
        // 如果配置源不支持监听，返回 nil
        Watch() Watcher
}

// Watcher 定义配置变更监听接口
type Watcher interface {
        // Start 启动监听
        // 当配置发生变更时，通过 channel 发送事件
        Start(ctx context.Context) (&lt;-chan Event, error)

        // Stop 停止监听
        Stop() error
}

// Event 定义配置变更事件
type Event struct {
        // Type 事件类型
        Type EventType

        // Source 触发事件的配置源名称
        Source string

        // Keys 发生变更的配置键列表（可选）
        // 如果为空，表示需要重新加载整个配置源
        Keys []string

        // Timestamp 事件发生时间
        Timestamp time.Time

        // Error 如果监听过程中发生错误
        Error error
}

// EventType 事件类型枚举
type EventType int

const (
        EventTypeUnknown EventType = iota
        EventTypeCreate            // 新增配置
        EventTypeUpdate            // 更新配置
        EventTypeDelete            // 删除配置
        EventTypeReload            // 全量重载
        EventTypeError             // 监听错误
)

func (e EventType) String() string <span class="cov8" title="1">{
        switch e </span>{
        case EventTypeCreate:<span class="cov8" title="1">
                return "create"</span>
        case EventTypeUpdate:<span class="cov8" title="1">
                return "update"</span>
        case EventTypeDelete:<span class="cov8" title="1">
                return "delete"</span>
        case EventTypeReload:<span class="cov8" title="1">
                return "reload"</span>
        case EventTypeError:<span class="cov8" title="1">
                return "error"</span>
        default:<span class="cov8" title="1">
                return "unknown"</span>
        }
}

// Config 定义配置访问接口
// 提供类型安全的配置值获取方法
type Config interface {
        // Get 获取原始配置值
        // key 支持点分隔符表示嵌套路径，如 "database.host"
        Get(key string) (Value, bool)

        // GetString 获取字符串值，不存在时返回默认值
        GetString(key string, defaultVal string) string

        // GetInt 获取整数值，不存在或类型转换失败时返回默认值
        GetInt(key string, defaultVal int) int

        // GetInt64 获取 int64 值
        GetInt64(key string, defaultVal int64) int64

        // GetFloat64 获取浮点数值
        GetFloat64(key string, defaultVal float64) float64

        // GetBool 获取布尔值
        GetBool(key string, defaultVal bool) bool

        // GetDuration 获取时间间隔值
        // 支持格式: "10s", "5m", "1h30m" 等
        GetDuration(key string, defaultVal time.Duration) time.Duration

        // GetStringSlice 获取字符串切片
        // 支持 JSON 数组格式或逗号分隔格式
        GetStringSlice(key string, defaultVal []string) []string

        // GetStringMap 获取字符串映射
        GetStringMap(key string, defaultVal map[string]string) map[string]string

        // Keys 返回所有配置键
        Keys() []string

        // Has 检查配置键是否存在
        Has(key string) bool
}

// configImpl Config 接口的实现
type configImpl struct {
        data map[string]Value
}

// newConfigImpl 创建配置实例
func newConfigImpl() *configImpl <span class="cov8" title="1">{
        return &amp;configImpl{
                data: make(map[string]Value),
        }
}</span>

// newConfigImplFromMap 从 map 创建配置实例
func newConfigImplFromMap(data map[string]Value) *configImpl <span class="cov8" title="1">{
        return &amp;configImpl{
                data: data,
        }
}</span>

func (c *configImpl) Get(key string) (Value, bool) <span class="cov8" title="1">{
        val, ok := c.data[key]
        return val, ok
}</span>

func (c *configImpl) GetString(key string, defaultVal string) string <span class="cov8" title="1">{
        if val, ok := c.data[key]; ok </span><span class="cov8" title="1">{
                return val.String()
        }</span>
        <span class="cov8" title="1">return defaultVal</span>
}

func (c *configImpl) GetInt(key string, defaultVal int) int <span class="cov8" title="1">{
        if val, ok := c.data[key]; ok </span><span class="cov8" title="1">{
                return val.Int(defaultVal)
        }</span>
        <span class="cov8" title="1">return defaultVal</span>
}

func (c *configImpl) GetInt64(key string, defaultVal int64) int64 <span class="cov0" title="0">{
        if val, ok := c.data[key]; ok </span><span class="cov0" title="0">{
                return val.Int64(defaultVal)
        }</span>
        <span class="cov0" title="0">return defaultVal</span>
}

func (c *configImpl) GetFloat64(key string, defaultVal float64) float64 <span class="cov0" title="0">{
        if val, ok := c.data[key]; ok </span><span class="cov0" title="0">{
                return val.Float64(defaultVal)
        }</span>
        <span class="cov0" title="0">return defaultVal</span>
}

func (c *configImpl) GetBool(key string, defaultVal bool) bool <span class="cov8" title="1">{
        if val, ok := c.data[key]; ok </span><span class="cov8" title="1">{
                return val.Bool(defaultVal)
        }</span>
        <span class="cov8" title="1">return defaultVal</span>
}

func (c *configImpl) GetDuration(key string, defaultVal time.Duration) time.Duration <span class="cov8" title="1">{
        if val, ok := c.data[key]; ok </span><span class="cov8" title="1">{
                return val.Duration(defaultVal)
        }</span>
        <span class="cov8" title="1">return defaultVal</span>
}

func (c *configImpl) GetStringSlice(key string, defaultVal []string) []string <span class="cov8" title="1">{
        if val, ok := c.data[key]; ok </span><span class="cov8" title="1">{
                return val.StringSlice(defaultVal)
        }</span>
        <span class="cov8" title="1">return defaultVal</span>
}

func (c *configImpl) GetStringMap(key string, defaultVal map[string]string) map[string]string <span class="cov8" title="1">{
        if val, ok := c.data[key]; ok </span><span class="cov8" title="1">{
                return val.StringMap(defaultVal)
        }</span>
        <span class="cov8" title="1">return defaultVal</span>
}

func (c *configImpl) Keys() []string <span class="cov8" title="1">{
        keys := make([]string, 0, len(c.data))
        for k := range c.data </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">return keys</span>
}

func (c *configImpl) Has(key string) bool <span class="cov8" title="1">{
        _, ok := c.data[key]
        return ok
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "errors"
        "fmt"
)

var (
        // ErrSourceNotFound 配置源未找到
        ErrSourceNotFound = errors.New("config source not found")

        // ErrKeyNotFound 配置键不存在
        ErrKeyNotFound = errors.New("config key not found")

        // ErrTypeMismatch 类型转换失败
        ErrTypeMismatch = errors.New("config value type mismatch")

        // ErrLoadFailed 加载配置失败
        ErrLoadFailed = errors.New("failed to load config")

        // ErrWatchFailed 启动监听失败
        ErrWatchFailed = errors.New("failed to start config watch")
)

// SourceError 配置源错误
type SourceError struct {
        Source string
        Err    error
}

func (e *SourceError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("source %s: %v", e.Source, e.Err)
}</span>

func (e *SourceError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "context"
        "fmt"
        "sort"
        "sync"
)

// Manager 配置管理器
// 负责协调多个配置源、执行合并、处理热更新
type Manager struct {
        mu       sync.RWMutex
        sources  []Source
        merger   Merger
        config   *configImpl
        watchers []Watcher
        onChange []ChangeCallback
        ctx      context.Context
        cancel   context.CancelFunc
}

// ChangeCallback 配置变更回调函数
// oldConfig 可能为 nil（首次加载时）
type ChangeCallback func(event Event, oldConfig, newConfig Config)

// NewManager 创建配置管理器
func NewManager(opts ...ManagerOption) *Manager <span class="cov8" title="1">{
        ctx, cancel := context.WithCancel(context.Background())
        m := &amp;Manager{
                sources:  make([]Source, 0),
                merger:   NewDefaultMerger(),
                config:   newConfigImpl(),
                onChange: make([]ChangeCallback, 0),
                ctx:      ctx,
                cancel:   cancel,
        }

        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(m)
        }</span>

        <span class="cov8" title="1">return m</span>
}

// AddSource 添加配置源
// 配置源按优先级排序，高优先级的源在合并时覆盖低优先级
func (m *Manager) AddSource(sources ...Source) *Manager <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.sources = append(m.sources, sources...)
        // 按优先级排序（从低到高，便于后续合并时高优先级覆盖低优先级）
        sort.Slice(m.sources, func(i, j int) bool </span><span class="cov8" title="1">{
                return m.sources[i].Priority() &lt; m.sources[j].Priority()
        }</span>)

        <span class="cov8" title="1">return m</span>
}

// Load 加载所有配置源并合并
func (m *Manager) Load(ctx context.Context) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        return m.loadLocked(ctx)
}</span>

// loadLocked 内部加载方法（需要持有锁）
func (m *Manager) loadLocked(ctx context.Context) error <span class="cov8" title="1">{
        allValues := make([]map[string]Value, 0, len(m.sources))

        for _, source := range m.sources </span><span class="cov8" title="1">{
                values, err := source.Load(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to load from source %s: %w", source.Name(), err)
                }</span>
                <span class="cov8" title="1">allValues = append(allValues, values)</span>
        }

        // 合并所有配置（按优先级，后面的覆盖前面的）
        <span class="cov8" title="1">merged := m.merger.Merge(allValues...)
        m.config = newConfigImplFromMap(merged)

        return nil</span>
}

// Watch 启动所有配置源的监听
func (m *Manager) Watch() error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        for _, source := range m.sources </span><span class="cov8" title="1">{
                watcher := source.Watch()
                if watcher == nil </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">eventCh, err := watcher.Start(m.ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to start watcher for source %s: %w", source.Name(), err)
                }</span>

                <span class="cov8" title="1">m.watchers = append(m.watchers, watcher)

                // 启动 goroutine 处理事件
                go m.handleEvents(source.Name(), eventCh)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// handleEvents 处理配置变更事件
func (m *Manager) handleEvents(sourceName string, eventCh &lt;-chan Event) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-m.ctx.Done():<span class="cov8" title="1">
                        return</span>
                case event, ok := &lt;-eventCh:<span class="cov8" title="1">
                        if !ok </span><span class="cov8" title="1">{
                                return
                        }</span>

                        <span class="cov8" title="1">if event.Type == EventTypeError </span><span class="cov0" title="0">{
                                // 记录错误但不停止监听
                                m.notifyChange(event, nil, nil)
                                continue</span>
                        }

                        // 重新加载配置
                        <span class="cov8" title="1">m.mu.Lock()
                        oldConfig := m.config.clone()
                        if err := m.loadLocked(m.ctx); err != nil </span><span class="cov0" title="0">{
                                m.mu.Unlock()
                                m.notifyChange(Event{
                                        Type:      EventTypeError,
                                        Source:    sourceName,
                                        Timestamp: event.Timestamp,
                                        Error:     err,
                                }, nil, nil)
                                continue</span>
                        }
                        <span class="cov8" title="1">newConfig := m.config.clone()
                        m.mu.Unlock()

                        m.notifyChange(event, oldConfig, newConfig)</span>
                }
        }
}

// OnChange 注册配置变更回调
func (m *Manager) OnChange(callback ChangeCallback) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.onChange = append(m.onChange, callback)
}</span>

// notifyChange 通知所有回调
func (m *Manager) notifyChange(event Event, oldConfig, newConfig Config) <span class="cov8" title="1">{
        m.mu.RLock()
        callbacks := make([]ChangeCallback, len(m.onChange))
        copy(callbacks, m.onChange)
        m.mu.RUnlock()

        for _, cb := range callbacks </span><span class="cov8" title="1">{
                cb(event, oldConfig, newConfig)
        }</span>
}

// Config 获取当前配置（只读）
func (m *Manager) Config() Config <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.config
}</span>

// Close 关闭管理器，停止所有监听
func (m *Manager) Close() error <span class="cov8" title="1">{
        m.cancel()

        var errs []error
        for _, w := range m.watchers </span><span class="cov8" title="1">{
                if err := w.Stop(); err != nil </span><span class="cov8" title="1">{
                        errs = append(errs, err)
                }</span>
        }

        <span class="cov8" title="1">if len(errs) &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("errors while closing watchers: %v", errs)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// clone 克隆配置（用于热更新时比较）
func (c *configImpl) clone() *configImpl <span class="cov8" title="1">{
        newData := make(map[string]Value, len(c.data))
        for k, v := range c.data </span><span class="cov8" title="1">{
                newData[k] = v
        }</span>
        <span class="cov8" title="1">return &amp;configImpl{data: newData}</span>
}

// NewDefaultMerger 创建默认合并器
func NewDefaultMerger() Merger <span class="cov8" title="1">{
        return &amp;defaultMerger{}
}</span>

// defaultMerger 默认合并器实现
type defaultMerger struct{}

func (m *defaultMerger) Merge(maps ...map[string]Value) map[string]Value <span class="cov8" title="1">{
        result := make(map[string]Value)

        for _, configMap := range maps </span><span class="cov8" title="1">{
                for k, v := range configMap </span><span class="cov8" title="1">{
                        result[k] = v
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package merge

import "github.com/CloudRoamer/aimo-libs/config"

// Merger 定义配置合并策略接口
type Merger interface {
        // Merge 合并多个配置映射
        // 按顺序合并，后面的覆盖前面的
        Merge(maps ...map[string]config.Value) map[string]config.Value
}

// DefaultMerger 默认合并器
// 简单的覆盖策略：后面的值覆盖前面的
type DefaultMerger struct{}

// NewDefaultMerger 创建默认合并器
func NewDefaultMerger() *DefaultMerger <span class="cov8" title="1">{
        return &amp;DefaultMerger{}
}</span>

func (m *DefaultMerger) Merge(maps ...map[string]config.Value) map[string]config.Value <span class="cov8" title="1">{
        result := make(map[string]config.Value)

        for _, configMap := range maps </span><span class="cov8" title="1">{
                for k, v := range configMap </span><span class="cov8" title="1">{
                        result[k] = v
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

// ManagerOption 配置管理器选项
type ManagerOption func(*Manager)

// WithMerger 设置自定义合并器
func WithMerger(merger Merger) ManagerOption <span class="cov0" title="0">{
        return func(m *Manager) </span><span class="cov0" title="0">{
                m.merger = merger
        }</span>
}

// Merger 定义配置合并策略接口
type Merger interface {
        // Merge 合并多个配置映射
        // 按顺序合并，后面的覆盖前面的
        Merge(maps ...map[string]Value) map[string]Value
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package consul

import (
        "context"
        "fmt"
        "strings"
        "sync"

        consulapi "github.com/hashicorp/consul/api"

        "github.com/CloudRoamer/aimo-libs/config"
)

const (
        DefaultPriority = 80
        DefaultPrefix   = "config"
)

// Source Consul KV 配置源
type Source struct {
        client    *consulapi.Client
        prefix    string
        priority  int
        separator string

        mu      sync.RWMutex
        watcher *watcher
}

// New 创建 Consul KV 配置源
func New(address string, opts ...Option) (*Source, error) <span class="cov8" title="1">{
        cfg := consulapi.DefaultConfig()
        cfg.Address = address

        client, err := consulapi.NewClient(cfg)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create consul client: %w", err)
        }</span>

        // 验证连接
        <span class="cov8" title="1">_, err = client.Status().Leader()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to consul at %s: %w", address, err)
        }</span>

        <span class="cov8" title="1">s := &amp;Source{
                client:    client,
                prefix:    DefaultPrefix,
                priority:  DefaultPriority,
                separator: "/",
        }

        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(s)
        }</span>

        <span class="cov8" title="1">return s, nil</span>
}

func (s *Source) Name() string <span class="cov8" title="1">{
        return "consul"
}</span>

func (s *Source) Priority() int <span class="cov8" title="1">{
        return s.priority
}</span>

func (s *Source) Load(ctx context.Context) (map[string]config.Value, error) <span class="cov8" title="1">{
        kv := s.client.KV()

        pairs, _, err := kv.List(s.prefix, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list keys from consul: %w", err)
        }</span>

        <span class="cov8" title="1">result := make(map[string]config.Value)
        prefixWithSep := s.prefix + "/"

        for _, pair := range pairs </span><span class="cov0" title="0">{
                // 移除前缀并转换分隔符
                key := strings.TrimPrefix(pair.Key, prefixWithSep)
                if key == "" || key == pair.Key </span><span class="cov0" title="0">{
                        // 跳过前缀本身或未匹配前缀的 key
                        continue</span>
                }

                // 将路径分隔符转换为点分隔符
                <span class="cov0" title="0">key = strings.ReplaceAll(key, "/", ".")

                result[key] = config.NewValue(string(pair.Value))</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// Watch 返回 Consul 监听器
func (s *Source) Watch() config.Watcher <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.watcher == nil </span><span class="cov8" title="1">{
                s.watcher = newWatcher(s.client, s.prefix)
        }</span>
        <span class="cov8" title="1">return s.watcher</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package consul

import (
        "strings"

        consulapi "github.com/hashicorp/consul/api"
)

// Option Consul 配置源选项
type Option func(*Source)

// WithPrefix 设置 KV 路径前缀
// 例如: "config/prod/myapp"
func WithPrefix(prefix string) Option <span class="cov8" title="1">{
        return func(s *Source) </span><span class="cov8" title="1">{
                s.prefix = strings.TrimSuffix(prefix, "/")
        }</span>
}

// WithPriority 设置优先级
func WithPriority(p int) Option <span class="cov8" title="1">{
        return func(s *Source) </span><span class="cov8" title="1">{
                s.priority = p
        }</span>
}

// WithToken 设置 ACL Token
// 注意：需要在创建 Source 前通过 consulapi.Config 设置
func WithToken(token string) Option <span class="cov0" title="0">{
        return func(s *Source) </span>{<span class="cov0" title="0">
                // Consul client 的 config 字段是私有的
                // Token 应该在创建 client 前通过 consulapi.Config 设置
                // 这里保留为空实现，实际使用时应该通过 WithConfig 选项
        }</span>
}

// WithConfig 使用自定义 Consul 配置
func WithConfig(cfg *consulapi.Config) Option <span class="cov0" title="0">{
        return func(s *Source) </span><span class="cov0" title="0">{
                client, err := consulapi.NewClient(cfg)
                if err == nil </span><span class="cov0" title="0">{
                        s.client = client
                }</span>
        }
}

// WithSeparator 设置路径分隔符（默认为 "/"）
func WithSeparator(sep string) Option <span class="cov0" title="0">{
        return func(s *Source) </span><span class="cov0" title="0">{
                s.separator = sep
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package consul

import (
        "context"
        "strings"
        "time"

        consulapi "github.com/hashicorp/consul/api"

        "github.com/CloudRoamer/aimo-libs/config"
)

const (
        // Consul blocking query 默认等待时间
        defaultWaitTime = 5 * time.Minute
        // 错误后重试等待时间
        retryWaitTime = 5 * time.Second
)

type watcher struct {
        client    *consulapi.Client
        prefix    string
        lastIndex uint64
        stopCh    chan struct{}
        eventCh   chan config.Event
}

func newWatcher(client *consulapi.Client, prefix string) *watcher <span class="cov8" title="1">{
        return &amp;watcher{
                client: client,
                prefix: prefix,
                stopCh: make(chan struct{}),
        }
}</span>

func (w *watcher) Start(ctx context.Context) (&lt;-chan config.Event, error) <span class="cov0" title="0">{
        w.eventCh = make(chan config.Event, 10)

        go w.watch(ctx)

        return w.eventCh, nil
}</span>

func (w *watcher) watch(ctx context.Context) <span class="cov0" title="0">{
        defer close(w.eventCh)

        kv := w.client.KV()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-w.stopCh:<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0"></span>
                }

                // 使用 Consul blocking query 等待变更
                <span class="cov0" title="0">opts := &amp;consulapi.QueryOptions{
                        WaitIndex: w.lastIndex,
                        WaitTime:  defaultWaitTime,
                }

                pairs, meta, err := kv.List(w.prefix, opts.WithContext(ctx))
                if err != nil </span><span class="cov0" title="0">{
                        w.eventCh &lt;- config.Event{
                                Type:      config.EventTypeError,
                                Source:    "consul",
                                Timestamp: time.Now(),
                                Error:     err,
                        }
                        // 错误后等待重试，避免频繁请求
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case &lt;-w.stopCh:<span class="cov0" title="0">
                                return</span>
                        case &lt;-time.After(retryWaitTime):<span class="cov0" title="0">
                                continue</span>
                        }
                }

                // 如果索引发生变化，说明有配置更新
                <span class="cov0" title="0">if meta.LastIndex &gt; w.lastIndex </span><span class="cov0" title="0">{
                        w.lastIndex = meta.LastIndex

                        // 收集变更的 key（转换为配置 key 格式）
                        keys := make([]string, 0, len(pairs))
                        prefixWithSep := w.prefix + "/"
                        for _, pair := range pairs </span><span class="cov0" title="0">{
                                key := strings.TrimPrefix(pair.Key, prefixWithSep)
                                if key != "" &amp;&amp; key != pair.Key </span><span class="cov0" title="0">{
                                        key = strings.ReplaceAll(key, "/", ".")
                                        keys = append(keys, key)
                                }</span>
                        }

                        <span class="cov0" title="0">w.eventCh &lt;- config.Event{
                                Type:      config.EventTypeReload,
                                Source:    "consul",
                                Keys:      keys,
                                Timestamp: time.Now(),
                        }</span>
                }
        }
}

func (w *watcher) Stop() error <span class="cov0" title="0">{
        close(w.stopCh)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package env

import (
        "context"
        "os"
        "strings"

        "github.com/CloudRoamer/aimo-libs/config"
)

const (
        // DefaultPriority 环境变量优先级最高
        DefaultPriority = 100
)

// Source 环境变量配置源
type Source struct {
        prefix      string              // 环境变量前缀，如 "APP_"
        separator   string              // key 分隔符，默认 "_"
        priority    int                 // 优先级
        keyMapping  func(string) string // 自定义 key 映射函数
}

// Option 配置选项
type Option func(*Source)

// WithPrefix 设置环境变量前缀
func WithPrefix(prefix string) Option <span class="cov8" title="1">{
        return func(s *Source) </span><span class="cov8" title="1">{
                s.prefix = prefix
        }</span>
}

// WithSeparator 设置层级分隔符
func WithSeparator(sep string) Option <span class="cov0" title="0">{
        return func(s *Source) </span><span class="cov0" title="0">{
                s.separator = sep
        }</span>
}

// WithPriority 设置优先级
func WithPriority(p int) Option <span class="cov8" title="1">{
        return func(s *Source) </span><span class="cov8" title="1">{
                s.priority = p
        }</span>
}

// WithKeyMapping 设置自定义 key 映射函数
// 用于将环境变量名转换为配置 key
// 例如: APP_DATABASE_HOST -&gt; database.host
func WithKeyMapping(fn func(string) string) Option <span class="cov8" title="1">{
        return func(s *Source) </span><span class="cov8" title="1">{
                s.keyMapping = fn
        }</span>
}

// New 创建环境变量配置源
func New(opts ...Option) *Source <span class="cov8" title="1">{
        s := &amp;Source{
                prefix:    "",
                separator: "_",
                priority:  DefaultPriority,
        }

        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(s)
        }</span>

        // 默认 key 映射：移除前缀，将分隔符替换为点，转小写
        <span class="cov8" title="1">if s.keyMapping == nil </span><span class="cov8" title="1">{
                s.keyMapping = func(envKey string) string </span><span class="cov8" title="1">{
                        key := envKey
                        if s.prefix != "" </span><span class="cov8" title="1">{
                                key = strings.TrimPrefix(key, s.prefix)
                        }</span>
                        <span class="cov8" title="1">key = strings.ToLower(key)
                        key = strings.ReplaceAll(key, s.separator, ".")
                        return key</span>
                }
        }

        <span class="cov8" title="1">return s</span>
}

func (s *Source) Name() string <span class="cov8" title="1">{
        return "env"
}</span>

func (s *Source) Priority() int <span class="cov8" title="1">{
        return s.priority
}</span>

func (s *Source) Load(ctx context.Context) (map[string]config.Value, error) <span class="cov8" title="1">{
        result := make(map[string]config.Value)

        for _, env := range os.Environ() </span><span class="cov8" title="1">{
                parts := strings.SplitN(env, "=", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">key, value := parts[0], parts[1]

                // 如果设置了前缀，只处理匹配前缀的环境变量
                if s.prefix != "" &amp;&amp; !strings.HasPrefix(key, s.prefix) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">configKey := s.keyMapping(key)
                result[configKey] = config.NewValue(value)</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// Watch 环境变量不支持监听
func (s *Source) Watch() config.Watcher <span class="cov8" title="1">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package file

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "sync"

        "github.com/CloudRoamer/aimo-libs/config"
        "github.com/CloudRoamer/aimo-libs/config/codec"
)

const (
        // DefaultPriority 文件配置优先级
        DefaultPriority = 60
)

// Source 文件配置源
type Source struct {
        path     string      // 配置文件路径
        codec    codec.Codec // 编解码器
        priority int         // 优先级

        mu      sync.RWMutex
        watcher *watcher
}

// Option 配置选项
type Option func(*Source)

// WithCodec 设置编解码器
func WithCodec(c codec.Codec) Option <span class="cov0" title="0">{
        return func(s *Source) </span><span class="cov0" title="0">{
                s.codec = c
        }</span>
}

// WithPriority 设置优先级
func WithPriority(p int) Option <span class="cov0" title="0">{
        return func(s *Source) </span><span class="cov0" title="0">{
                s.priority = p
        }</span>
}

// New 创建文件配置源
func New(path string, opts ...Option) (*Source, error) <span class="cov8" title="1">{
        // 检查文件是否存在
        if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("config file not found: %s", path)
        }</span>

        <span class="cov8" title="1">s := &amp;Source{
                path:     path,
                priority: DefaultPriority,
        }

        // 根据文件扩展名选择默认编解码器
        ext := strings.ToLower(filepath.Ext(path))
        switch ext </span>{
        case ".json":<span class="cov8" title="1">
                s.codec = codec.JSON</span>
        case ".yaml", ".yml":<span class="cov8" title="1">
                s.codec = codec.YAML</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported file format: %s", ext)</span>
        }

        <span class="cov8" title="1">for _, opt := range opts </span><span class="cov0" title="0">{
                opt(s)
        }</span>

        <span class="cov8" title="1">return s, nil</span>
}

func (s *Source) Name() string <span class="cov8" title="1">{
        return "file:" + s.path
}</span>

func (s *Source) Priority() int <span class="cov8" title="1">{
        return s.priority
}</span>

func (s *Source) Load(ctx context.Context) (map[string]config.Value, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(s.path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        // 解码为 map
        <span class="cov8" title="1">var raw map[string]any
        if err := s.codec.Decode(data, &amp;raw); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to decode config: %w", err)
        }</span>

        // 扁平化嵌套结构
        <span class="cov8" title="1">result := make(map[string]config.Value)
        flatten("", raw, result)

        return result, nil</span>
}

// flatten 将嵌套 map 扁平化为点分隔的 key
func flatten(prefix string, data map[string]any, result map[string]config.Value) <span class="cov8" title="1">{
        for k, v := range data </span><span class="cov8" title="1">{
                key := k
                if prefix != "" </span><span class="cov8" title="1">{
                        key = prefix + "." + k
                }</span>

                <span class="cov8" title="1">switch val := v.(type) </span>{
                case map[string]any:<span class="cov8" title="1">
                        flatten(key, val, result)</span>
                case map[any]any:<span class="cov0" title="0">
                        // YAML 可能返回这种类型
                        converted := make(map[string]any)
                        for mk, mv := range val </span><span class="cov0" title="0">{
                                converted[fmt.Sprintf("%v", mk)] = mv
                        }</span>
                        <span class="cov0" title="0">flatten(key, converted, result)</span>
                default:<span class="cov8" title="1">
                        result[key] = config.NewValueFromInterface(v)</span>
                }
        }
}

// Watch 返回文件监听器（本阶段暂不实现）
func (s *Source) Watch() config.Watcher <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package file

import (
        "context"
        "time"

        "github.com/fsnotify/fsnotify"

        "github.com/CloudRoamer/aimo-libs/config"
)

// watcher 文件监听器
type watcher struct {
        path    string
        stopCh  chan struct{}
        eventCh chan config.Event
}

func newWatcher(path string) *watcher <span class="cov0" title="0">{
        return &amp;watcher{
                path:   path,
                stopCh: make(chan struct{}),
        }
}</span>

func (w *watcher) Start(ctx context.Context) (&lt;-chan config.Event, error) <span class="cov0" title="0">{
        fsWatcher, err := fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := fsWatcher.Add(w.path); err != nil </span><span class="cov0" title="0">{
                fsWatcher.Close()
                return nil, err
        }</span>

        <span class="cov0" title="0">w.eventCh = make(chan config.Event, 10)

        go w.watch(ctx, fsWatcher)

        return w.eventCh, nil</span>
}

func (w *watcher) watch(ctx context.Context, fsWatcher *fsnotify.Watcher) <span class="cov0" title="0">{
        defer close(w.eventCh)
        defer fsWatcher.Close()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-w.stopCh:<span class="cov0" title="0">
                        return</span>
                case event, ok := &lt;-fsWatcher.Events:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>

                        // 只关注写入和创建事件
                        <span class="cov0" title="0">if event.Op&amp;fsnotify.Write == fsnotify.Write || event.Op&amp;fsnotify.Create == fsnotify.Create </span><span class="cov0" title="0">{
                                w.eventCh &lt;- config.Event{
                                        Type:      config.EventTypeUpdate,
                                        Source:    "file:" + w.path,
                                        Timestamp: time.Now(),
                                }
                        }</span>
                case err, ok := &lt;-fsWatcher.Errors:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">w.eventCh &lt;- config.Event{
                                Type:      config.EventTypeError,
                                Source:    "file:" + w.path,
                                Timestamp: time.Now(),
                                Error:     err,
                        }</span>
                }
        }
}

func (w *watcher) Stop() error <span class="cov0" title="0">{
        close(w.stopCh)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package postgres

// Option PostgreSQL 配置源选项
type Option func(*Source)

// WithTable 设置配置表名
func WithTable(table string) Option <span class="cov8" title="1">{
        return func(s *Source) </span><span class="cov8" title="1">{
                s.table = table
        }</span>
}

// WithColumns 设置列名
func WithColumns(keyCol, valueCol string) Option <span class="cov8" title="1">{
        return func(s *Source) </span><span class="cov8" title="1">{
                s.keyCol = keyCol
                s.valueCol = valueCol
        }</span>
}

// WithPriority 设置优先级
func WithPriority(p int) Option <span class="cov0" title="0">{
        return func(s *Source) </span><span class="cov0" title="0">{
                s.priority = p
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "fmt"

        _ "github.com/lib/pq"

        "github.com/CloudRoamer/aimo-libs/config"
)

const (
        DefaultPriority = 70
        DefaultTable    = "app_config"
        DefaultKeyCol   = "key"
        DefaultValueCol = "value"
)

// Source PostgreSQL 配置源
type Source struct {
        db       *sql.DB
        table    string
        keyCol   string
        valueCol string
        priority int
}

// New 创建 PostgreSQL 配置源
func New(dsn string, opts ...Option) (*Source, error) <span class="cov8" title="1">{
        db, err := sql.Open("postgres", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        <span class="cov8" title="1">if err := db.Ping(); err != nil </span><span class="cov8" title="1">{
                db.Close()
                return nil, fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        <span class="cov0" title="0">s := &amp;Source{
                db:       db,
                table:    DefaultTable,
                keyCol:   DefaultKeyCol,
                valueCol: DefaultValueCol,
                priority: DefaultPriority,
        }

        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(s)
        }</span>

        <span class="cov0" title="0">return s, nil</span>
}

func (s *Source) Name() string <span class="cov8" title="1">{
        return "postgres"
}</span>

func (s *Source) Priority() int <span class="cov8" title="1">{
        return s.priority
}</span>

func (s *Source) Load(ctx context.Context) (map[string]config.Value, error) <span class="cov0" title="0">{
        query := fmt.Sprintf(
                "SELECT %s, %s FROM %s",
                s.keyCol, s.valueCol, s.table,
        )

        rows, err := s.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query config: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        result := make(map[string]config.Value)
        for rows.Next() </span><span class="cov0" title="0">{
                var key, value string
                if err := rows.Scan(&amp;key, &amp;value); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan row: %w", err)
                }</span>
                <span class="cov0" title="0">result[key] = config.NewValue(value)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating rows: %w", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// Watch PostgreSQL 源暂不支持监听
// 可以通过 LISTEN/NOTIFY 机制实现，但这里保持简单
func (s *Source) Watch() config.Watcher <span class="cov8" title="1">{
        return nil
}</span>

// Close 关闭数据库连接
func (s *Source) Close() error <span class="cov0" title="0">{
        return s.db.Close()
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package config

import (
        "encoding/json"
        "fmt"
        "strconv"
        "strings"
        "time"
)

// Value 封装配置值，提供类型转换方法
type Value struct {
        raw any // 原始值
}

// NewValue 从字符串创建 Value
func NewValue(s string) Value <span class="cov8" title="1">{
        return Value{raw: s}
}</span>

// NewValueFromInterface 从任意类型创建 Value
func NewValueFromInterface(v any) Value <span class="cov8" title="1">{
        return Value{raw: v}
}</span>

// Raw 返回原始值
func (v Value) Raw() any <span class="cov8" title="1">{
        return v.raw
}</span>

// String 返回字符串表示
func (v Value) String() string <span class="cov8" title="1">{
        if v.raw == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">switch val := v.raw.(type) </span>{
        case string:<span class="cov8" title="1">
                return val</span>
        default:<span class="cov8" title="1">
                return fmt.Sprintf("%v", val)</span>
        }
}

// Int 转换为整数
func (v Value) Int(defaultVal int) int <span class="cov8" title="1">{
        if v.raw == nil </span><span class="cov8" title="1">{
                return defaultVal
        }</span>

        <span class="cov8" title="1">switch val := v.raw.(type) </span>{
        case int:<span class="cov8" title="1">
                return val</span>
        case int64:<span class="cov8" title="1">
                return int(val)</span>
        case float64:<span class="cov8" title="1">
                return int(val)</span>
        case string:<span class="cov8" title="1">
                i, err := strconv.Atoi(val)
                if err != nil </span><span class="cov8" title="1">{
                        return defaultVal
                }</span>
                <span class="cov8" title="1">return i</span>
        default:<span class="cov0" title="0">
                return defaultVal</span>
        }
}

// Int64 转换为 int64
func (v Value) Int64(defaultVal int64) int64 <span class="cov0" title="0">{
        if v.raw == nil </span><span class="cov0" title="0">{
                return defaultVal
        }</span>

        <span class="cov0" title="0">switch val := v.raw.(type) </span>{
        case int64:<span class="cov0" title="0">
                return val</span>
        case int:<span class="cov0" title="0">
                return int64(val)</span>
        case float64:<span class="cov0" title="0">
                return int64(val)</span>
        case string:<span class="cov0" title="0">
                i, err := strconv.ParseInt(val, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return defaultVal
                }</span>
                <span class="cov0" title="0">return i</span>
        default:<span class="cov0" title="0">
                return defaultVal</span>
        }
}

// Float64 转换为浮点数
func (v Value) Float64(defaultVal float64) float64 <span class="cov8" title="1">{
        if v.raw == nil </span><span class="cov8" title="1">{
                return defaultVal
        }</span>

        <span class="cov8" title="1">switch val := v.raw.(type) </span>{
        case float64:<span class="cov0" title="0">
                return val</span>
        case float32:<span class="cov8" title="1">
                return float64(val)</span>
        case int:<span class="cov0" title="0">
                return float64(val)</span>
        case int64:<span class="cov0" title="0">
                return float64(val)</span>
        case string:<span class="cov8" title="1">
                f, err := strconv.ParseFloat(val, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return defaultVal
                }</span>
                <span class="cov0" title="0">return f</span>
        default:<span class="cov0" title="0">
                return defaultVal</span>
        }
}

// Bool 转换为布尔值
func (v Value) Bool(defaultVal bool) bool <span class="cov8" title="1">{
        if v.raw == nil </span><span class="cov8" title="1">{
                return defaultVal
        }</span>

        <span class="cov8" title="1">switch val := v.raw.(type) </span>{
        case bool:<span class="cov8" title="1">
                return val</span>
        case string:<span class="cov8" title="1">
                b, err := strconv.ParseBool(val)
                if err != nil </span><span class="cov8" title="1">{
                        return defaultVal
                }</span>
                <span class="cov8" title="1">return b</span>
        default:<span class="cov0" title="0">
                return defaultVal</span>
        }
}

// Duration 转换为时间间隔
func (v Value) Duration(defaultVal time.Duration) time.Duration <span class="cov8" title="1">{
        if v.raw == nil </span><span class="cov0" title="0">{
                return defaultVal
        }</span>

        <span class="cov8" title="1">switch val := v.raw.(type) </span>{
        case time.Duration:<span class="cov8" title="1">
                return val</span>
        case int64:<span class="cov8" title="1">
                return time.Duration(val)</span>
        case string:<span class="cov8" title="1">
                d, err := time.ParseDuration(val)
                if err != nil </span><span class="cov8" title="1">{
                        return defaultVal
                }</span>
                <span class="cov8" title="1">return d</span>
        default:<span class="cov0" title="0">
                return defaultVal</span>
        }
}

// StringSlice 转换为字符串切片
func (v Value) StringSlice(defaultVal []string) []string <span class="cov8" title="1">{
        if v.raw == nil </span><span class="cov0" title="0">{
                return defaultVal
        }</span>

        <span class="cov8" title="1">switch val := v.raw.(type) </span>{
        case []string:<span class="cov8" title="1">
                return val</span>
        case []any:<span class="cov8" title="1">
                result := make([]string, 0, len(val))
                for _, item := range val </span><span class="cov8" title="1">{
                        result = append(result, fmt.Sprintf("%v", item))
                }</span>
                <span class="cov8" title="1">return result</span>
        case string:<span class="cov8" title="1">
                // 尝试 JSON 解析
                var slice []string
                if err := json.Unmarshal([]byte(val), &amp;slice); err == nil </span><span class="cov8" title="1">{
                        return slice
                }</span>
                // 尝试逗号分隔
                <span class="cov8" title="1">parts := strings.Split(val, ",")
                result := make([]string, 0, len(parts))
                for _, p := range parts </span><span class="cov8" title="1">{
                        if trimmed := strings.TrimSpace(p); trimmed != "" </span><span class="cov8" title="1">{
                                result = append(result, trimmed)
                        }</span>
                }
                <span class="cov8" title="1">if len(result) &gt; 0 </span><span class="cov8" title="1">{
                        return result
                }</span>
                <span class="cov8" title="1">return defaultVal</span>
        default:<span class="cov0" title="0">
                return defaultVal</span>
        }
}

// StringMap 转换为字符串映射
func (v Value) StringMap(defaultVal map[string]string) map[string]string <span class="cov8" title="1">{
        if v.raw == nil </span><span class="cov0" title="0">{
                return defaultVal
        }</span>

        <span class="cov8" title="1">switch val := v.raw.(type) </span>{
        case map[string]string:<span class="cov8" title="1">
                return val</span>
        case map[string]any:<span class="cov8" title="1">
                result := make(map[string]string, len(val))
                for k, v := range val </span><span class="cov8" title="1">{
                        result[k] = fmt.Sprintf("%v", v)
                }</span>
                <span class="cov8" title="1">return result</span>
        case string:<span class="cov8" title="1">
                var m map[string]string
                if err := json.Unmarshal([]byte(val), &amp;m); err == nil </span><span class="cov8" title="1">{
                        return m
                }</span>
                <span class="cov8" title="1">return defaultVal</span>
        default:<span class="cov0" title="0">
                return defaultVal</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
